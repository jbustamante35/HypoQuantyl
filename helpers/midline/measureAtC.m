function [X , M , V] = measureAtC(scr, evecs, mns, w)
%% measureAtC: return measurements of the curve generated by PC scores
% Description
%
% Usage:
%   [X , M , V] = measureAtC(scr, evecs, mns, w)
%
% Input:
%   scr: PC scores of contour and midline mix (can also input contour)
%   evecs: eigenvectors of contour-midlines (can also input midline)
%   mns: mean values of contour-midlines (input [] if not back-projecting)
%   w: number of coordinates to represent the curve's origin and tip
%   isz: size of image to generate a binary mask for distance transform
%
% Output:
%   X: vectorized measurements
%   M: structure of measurements
%   V: miscellaneous measurements for visualizing output
%
% Author Julian Bustamante <jbustamante@wisc.edu>
%

%% Misc data
switch nargin
    case 2
        % Input contour (arg 1) and midline (arg 2)
        cntr  = scr;
        mline = evecs;
        mns   = [];
        w     = 4;
    case 3
        % Input contour-midline coefficents, eigenvectors, and means
        w = 4;
    case 4
        % Check if entering PC scores or full coordinates
        if isempty(mns)
            cntr  = scr;
            mline = evecs;
        end
    otherwise
        fprintf(2, 'Error with input (%d)\n', nargin);
        [X , M , V] = deal([]);
        return;
end

%% Determine if input should be back-projected
if ~isempty(mns)
    % Back-project score and separate contour and midline
    tsz            = 210;
    msz            = 50;
    [cntr , mline] = cmscr2cmvec(scr, evecs, mns, tsz, msz);
end

%% Contour measurements
M.clen  = sum(sum(diff(cntr, 1, 1) .^ 2, 2) .^ 0.5, 1);
M.carea = polyarea(cntr(:,1), cntr(:,2));

% Location and vector of apex 
% [account for elongated shape] [open vs closed hooks]


%% Midline measurements
M.mlen  = sum(sum(diff(mline, 1, 1) .^ 2, 2) .^ 0.5, 1);
V.mnrm  = getVectorField(mline);

% Midline tip direction, coordinate, and mean [origin and tip]
[M.odeg , M.orix , M.oriy , V.ox , V.ov] = getDeg(mline(1:w,:));
[M.tdeg , M.tipx , M.tipy , V.tx , V.tv] = getDeg(mline(end-w+1:end,:));

%% Contour-Midline association measurements
% 

% Midline along distance transform
% msk = double(poly2mask(cntr(:,1), cntr(:,2), isz(1), isz(2)));


%% Convert to array
X = struct2array(M);

end

function [sdeg , sx , sy , vx , svecs] = getDeg(snp)
%% getDeg
ps    = pcaAnalysis(snp, 1, 0, 'termpoints');
svecs = ps.EigVecs;
dx    = mean(diff(snp, 1, 1), 1);
dx    = dx / norm(dx);
dchk  = sign(dx * svecs);

vx   = dchk * svecs;
sdeg = rad2deg(atan2(vx(2), vx(1)));
smns = ps.MeanVals;
sx   = smns(1);
sy   = smns(2);

end
